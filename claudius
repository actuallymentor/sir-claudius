#!/bin/bash
set -e

# -----------------------------------------------------------
# claudius — run Claude Code inside a Docker container
# -----------------------------------------------------------

CLAUDIUS_VERSION="0.4.7"
REPO_URL="https://raw.githubusercontent.com/actuallymentor/sir-claudius/main/claudius"

IMAGE="${CLAUDE_SANDBOX_IMAGE:-actuallymentor/sir-claudius:latest}"
MODEL="${CLAUDE_MODEL:-claude-opus-4-6}"
TOKEN_FILE="$HOME/.claude-sandbox-token"

# ---- --version flag ----
if [ "${1:-}" = "--version" ] || [ "${1:-}" = "-v" ]; then
    echo "claudius $CLAUDIUS_VERSION"
    exit 0
fi

# ---- --help flag ----
if [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
    cat <<'EOF'
claudius — run Claude Code inside a Docker container

Usage: claudius [command...] [options] [-- claude args...]

Commands (chainable — combine in any order):
  yolo        Run with blanket permissions (--dangerously-skip-permissions)
  sandbox     Run without mounting a workspace; host files are read-only
  mudbox      Mount the workspace as read-only (explore code without modifying it)
  continue    Resume the most recent session (--continue)
  resume      Pick a session to resume, or pass a name (--resume)

Standalone commands:
  setup       Authenticate and save an OAuth token
  update      Fetch the latest script and pull the Docker image
  rebuild     Force-rebuild the Docker image with --no-cache
  history     List previous sessions (default: 15, or pass a number / "all" / "search text")
  history inspect <id>  Show the full log and details of a session

Options:
  --help, -h      Show this help message
  --version, -v   Show the claudius version

Examples:
  claudius                        Interactive session in the current directory
  claudius yolo                   Skip all permission prompts
  claudius mudbox                 Read-only workspace (code review, exploration)
  claudius yolo mudbox            Read-only workspace + skip permissions
  claudius sandbox yolo           No workspace + skip permissions
  claudius mudbox continue        Read-only workspace + resume last session
  claudius history                Show the 15 most recent sessions
  claudius history 50             Show the 50 most recent sessions
  claudius history all            Show all sessions
  claudius history "npm issue"    Search sessions by description (case-insensitive)
  claudius history inspect <id>   Inspect a session's full conversation log

Environment variables:
  CLAUDE_SANDBOX_IMAGE   Docker image to use (default: actuallymentor/sir-claudius:latest)
  CLAUDE_MODEL           Model to use (default: claude-opus-4-6)
  CLAUDE_CODE_OAUTH_TOKEN  OAuth token (skips credential lookup)
  ANTHROPIC_API_KEY      API key (fallback if no OAuth token)
  CLAUDIUS_DIR           Override the claudius cache directory (default: ~/.claudius)

All other arguments are passed through to Claude Code inside the container.
EOF
    exit 0
fi

# ---- setup subcommand: obtain a long-lived OAuth token ----
if [ "${1:-}" = "setup" ]; then

    echo "Opening browser to authenticate with Claude..."
    echo "The resulting token will be saved to $TOKEN_FILE"
    echo ""

    # claude setup-token prints the token to stdout
    # Strip ANSI codes and extract just the token (starts with sk-ant-)
    token=$(claude setup-token | sed 's/\x1b\[[0-9;]*[A-Za-z]//g' | grep -o 'sk-ant-[A-Za-z0-9_-]*' | head -n 1)

    if [ -z "$token" ]; then
        echo "Error: no token received from claude setup-token" >&2
        exit 1
    fi

    # Save with restricted permissions (owner read/write only)
    printf '%s' "$token" > "$TOKEN_FILE"
    chmod 600 "$TOKEN_FILE"

    echo ""
    echo "Token saved to $TOKEN_FILE"
    echo "You can now run: claudius"
    exit 0

fi

# ---- update subcommand: fetch latest script from GitHub and pull image ----
if [ "${1:-}" = "update" ]; then

    # When invoked via PATH, $0 has no directory component — resolve with command -v
    case "$0" in
        */*) SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")" ;;
        *)   SCRIPT_PATH="$(command -v "$0")" ;;
    esac

    # Download the latest script from GitHub
    echo "Fetching latest claudius from GitHub..." >&2
    TEMP_FILE=$(mktemp)
    trap "rm -f $TEMP_FILE" EXIT INT TERM

    if ! curl -fsSL --max-time 30 "$REPO_URL" -o "$TEMP_FILE"; then
        echo "Error: failed to download from $REPO_URL" >&2
        exit 1
    fi

    # Extract the version from the downloaded script
    NEW_VERSION=$(grep -m1 '^CLAUDIUS_VERSION=' "$TEMP_FILE" | cut -d'"' -f2)

    # If the version is identical, skip the script update
    if [ -n "$NEW_VERSION" ] && [ "$NEW_VERSION" = "$CLAUDIUS_VERSION" ]; then
        rm -f "$TEMP_FILE"
        echo "claudius is already up to date ($CLAUDIUS_VERSION)." >&2
    else
        # Replace the current script, using sudo if needed
        # Check the parent directory (not the file) since mv needs directory write permission
        if [ -w "$(dirname "$SCRIPT_PATH")" ]; then
            mv "$TEMP_FILE" "$SCRIPT_PATH"
            chmod +x "$SCRIPT_PATH"
        elif command -v sudo > /dev/null 2>&1; then
            echo "Writing to $SCRIPT_PATH requires elevated permissions..." >&2
            sudo mv "$TEMP_FILE" "$SCRIPT_PATH"
            sudo chmod +x "$SCRIPT_PATH"
        else
            echo "Error: cannot write to $SCRIPT_PATH and sudo is not available" >&2
            exit 1
        fi

        # Print version transition
        if [ -n "$NEW_VERSION" ]; then
            echo "claudius updated: $CLAUDIUS_VERSION → $NEW_VERSION" >&2
        else
            echo "Script updated." >&2
        fi
    fi

    # Pull the latest Docker image
    echo "Pulling $IMAGE..." >&2
    if ! docker pull "$IMAGE" >&2; then
        echo "Warning: image pull failed (you may need to rebuild locally)" >&2
    fi

    echo "Update complete." >&2
    exit 0

fi

# ---- rebuild subcommand: force rebuild with --no-cache ----
if [ "${1:-}" = "rebuild" ]; then

    echo "Rebuilding $IMAGE with --no-cache..." >&2
    # When invoked via PATH, $0 has no directory component — resolve with command -v
    case "$0" in
        */*) SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)" ;;
        *)   SCRIPT_DIR="$(dirname "$(command -v "$0")")" ;;
    esac

    if [ ! -f "$SCRIPT_DIR/Dockerfile" ]; then
        echo "Error: Dockerfile not found at $SCRIPT_DIR/Dockerfile" >&2
        exit 1
    fi

    docker build --no-cache -t "$IMAGE" "$SCRIPT_DIR"
    echo "Image $IMAGE rebuilt." >&2
    exit 0

fi

# ---- history subcommand: list previous sessions ----
if [ "${1:-}" = "history" ]; then

    HOST_CLAUDE_DIR="$HOME/.claude"
    HISTORY_FILE="$HOST_CLAUDE_DIR/history.jsonl"

    if [ ! -f "$HISTORY_FILE" ] || [ ! -s "$HISTORY_FILE" ]; then
        echo "No sessions found." >&2
        exit 0
    fi

    # ---- history inspect <session_id>: show full session details ----
    if [ "${2:-}" = "inspect" ]; then

        SESSION_ID="${3:-}"
        if [ -z "$SESSION_ID" ]; then
            echo "Usage: claudius history inspect <session_id>" >&2
            exit 1
        fi

        CLAUDIUS_DIR="${CLAUDIUS_DIR:-$HOME/.claudius}"
        MODIFIERS_FILE="$CLAUDIUS_DIR/session_modifiers"

        if ! command -v python3 > /dev/null 2>&1; then
            echo "Error: python3 is required for the history command" >&2
            exit 1
        fi

        python3 -c "
import json, sys, os, shutil
from datetime import datetime, timezone, timedelta

# ANSI helpers
BOLD = '\033[1m'
DIM = '\033[2m'
YELLOW = '\033[1;33m'
CYAN = '\033[36m'
GREEN = '\033[32m'
MAGENTA = '\033[35m'
RESET = '\033[0m'

term_width = shutil.get_terminal_size( ( 120, 24 ) ).columns

history_file = sys.argv[1]
session_id = sys.argv[2]
modifiers_file = sys.argv[3] if len(sys.argv) > 3 else ''

# --- Resolve session metadata from history.jsonl ---
session_meta = None
all_prompts = []
with open(history_file) as f:
    for line in f:
        line = line.strip()
        if not line:
            continue
        try:
            entry = json.loads(line)
        except json.JSONDecodeError:
            continue
        sid = entry.get('sessionId', '')
        if sid != session_id:
            continue
        ts = entry.get('timestamp', 0)
        prompt = entry.get('display', '').strip()
        project = entry.get('project', '')
        all_prompts.append({ 'ts': ts, 'prompt': prompt })
        if session_meta is None:
            session_meta = { 'sessionId': sid, 'project': project, 'first_ts': ts, 'latest_ts': ts, 'first_prompt': prompt }
        else:
            if ts < session_meta['first_ts']:
                session_meta['first_ts'] = ts
            if ts > session_meta['latest_ts']:
                session_meta['latest_ts'] = ts
            if not session_meta['first_prompt'] and prompt:
                session_meta['first_prompt'] = prompt

if not session_meta:
    print(f'Session {session_id} not found.', file=sys.stderr)
    sys.exit(1)

# --- Load modifiers ---
mods = ''
if modifiers_file and os.path.isfile(modifiers_file):
    with open(modifiers_file) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            parts = line.split('\t', 1)
            if parts[0] == session_id:
                mods = parts[1] if len(parts) > 1 else ''

# --- Locate session transcript ---
project = session_meta['project']
encoded_project = project.replace('/', '-') if project else ''
claude_dir = os.path.expanduser('~/.claude')
transcript_path = os.path.join(claude_dir, 'projects', encoded_project, f'{session_id}.jsonl') if encoded_project else ''

# --- Parse transcript if it exists ---
messages = []
tools_used = {}
model = ''
git_branch = ''
cc_version = ''

if transcript_path and os.path.isfile(transcript_path):
    with open(transcript_path) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                rec = json.loads(line)
            except json.JSONDecodeError:
                continue

            rec_type = rec.get('type', '')
            msg = rec.get('message', {})
            ts = rec.get('timestamp', '')

            # Pick up metadata from first records that have it
            if not git_branch:
                git_branch = rec.get('gitBranch', '')
            if not cc_version:
                cc_version = rec.get('version', '')

            if rec_type == 'user' and msg.get('role') == 'user':
                content = msg.get('content', '')
                # User messages can be a string or a list of content blocks
                if isinstance(content, str) and content.strip():
                    messages.append({ 'role': 'user', 'text': content.strip(), 'ts': ts })
                elif isinstance(content, list):
                    # Check for tool_result blocks (skip those) vs text
                    for block in content:
                        if isinstance(block, dict) and block.get('type') == 'tool_result':
                            continue
                        if isinstance(block, dict) and block.get('type') == 'text':
                            messages.append({ 'role': 'user', 'text': block['text'].strip(), 'ts': ts })

            elif rec_type == 'assistant':
                content = msg.get('content', '')
                if not model:
                    model = msg.get('model', '')
                if isinstance(content, str) and content.strip():
                    messages.append({ 'role': 'assistant', 'text': content.strip(), 'ts': ts })
                elif isinstance(content, list):
                    text_parts = []
                    for block in content:
                        if isinstance(block, dict):
                            if block.get('type') == 'text' and block.get('text', '').strip():
                                text_parts.append(block['text'].strip())
                            elif block.get('type') == 'tool_use':
                                name = block.get('name', 'unknown')
                                tools_used[name] = tools_used.get(name, 0) + 1
                    if text_parts:
                        messages.append({ 'role': 'assistant', 'text': '\n'.join(text_parts), 'ts': ts })

# --- Format timestamps ---
def fmt_ts(epoch_ms):
    try:
        dt = datetime.fromtimestamp(epoch_ms / 1000, tz=timezone.utc).astimezone()
        return dt.strftime('%H:%M %d-%m-%Y')
    except (ValueError, OSError):
        return '??:?? ??-??-????'

def fmt_duration(start_ms, end_ms):
    delta = timedelta(milliseconds=end_ms - start_ms)
    total_secs = int(delta.total_seconds())
    if total_secs < 60:
        return f'{total_secs}s'
    mins, secs = divmod(total_secs, 60)
    if mins < 60:
        return f'{mins}m {secs}s'
    hours, mins = divmod(mins, 60)
    return f'{hours}h {mins}m'

# --- Print session overview ---
hr = '─' * term_width

print(f'{hr}')
print(f'{BOLD}Session inspect{RESET}')
print(f'{hr}')
print()

# Metadata block
print(f'  {DIM}Session{RESET}    {session_id}')
print(f'  {DIM}Project{RESET}    {project}')
if git_branch:
    print(f'  {DIM}Branch{RESET}     {git_branch}')
if model:
    print(f'  {DIM}Model{RESET}      {model}')
if cc_version:
    print(f'  {DIM}CC version{RESET} {cc_version}')
if mods:
    print(f'  {DIM}Modifiers{RESET}  {YELLOW}{mods}{RESET}')

first_ts = fmt_ts(session_meta['first_ts'])
latest_ts = fmt_ts(session_meta['latest_ts'])
duration = fmt_duration(session_meta['first_ts'], session_meta['latest_ts'])
print(f'  {DIM}Started{RESET}    {first_ts}')
print(f'  {DIM}Latest{RESET}     {latest_ts}  {DIM}({duration}){RESET}')

# Resume command
mod_prefix = f' {mods}' if mods else ''
print(f'  {DIM}Resume{RESET}     {GREEN}claudius{mod_prefix} resume {session_id}{RESET}')
print()

# Stats
user_msgs = [m for m in messages if m['role'] == 'user']
asst_msgs = [m for m in messages if m['role'] == 'assistant']
print(f'  {DIM}Messages{RESET}   {len(user_msgs)} user, {len(asst_msgs)} assistant')

if tools_used:
    sorted_tools = sorted(tools_used.items(), key=lambda x: x[1], reverse=True)
    tool_str = ', '.join(f'{name} ({count})' for name, count in sorted_tools[:8])
    if len(sorted_tools) > 8:
        tool_str += f', +{len(sorted_tools) - 8} more'
    print(f'  {DIM}Tools{RESET}      {tool_str}')

print()
print(f'{hr}')
print(f'{BOLD}Conversation log{RESET}')
print(f'{hr}')

if not messages:
    if not transcript_path or not os.path.isfile(transcript_path):
        print(f'\n  {DIM}No transcript found at expected path:{RESET}')
        print(f'  {DIM}{transcript_path or \"(unknown project path)\"}{RESET}')
        # Show what we know from history.jsonl
        if all_prompts:
            print(f'\n  {DIM}Prompts from history (partial):{RESET}\n')
            for p in all_prompts:
                if p['prompt']:
                    print(f'  {CYAN}You:{RESET} {p[\"prompt\"]}')
    else:
        print(f'\n  {DIM}No conversation messages found in transcript.{RESET}')
    print()
else:
    print()
    for msg in messages:
        if msg['role'] == 'user':
            # Show user messages in full
            label = f'  {CYAN}You:{RESET} '
            text = msg['text'].replace('\n', f'\n       ')
            print(f'{label}{text}')
            print()
        else:
            # Show assistant messages, indent continuation lines
            label = f'  {MAGENTA}Claude:{RESET} '
            text = msg['text']
            # Wrap long lines to terminal width
            indent = '          '
            lines = text.split('\n')
            first = True
            for line in lines:
                if first:
                    print(f'{label}{line}')
                    first = False
                else:
                    print(f'{indent}{line}')
            print()

print(f'{hr}')
" "$HISTORY_FILE" "$SESSION_ID" "$MODIFIERS_FILE"

        exit 0
    fi

    # Parse optional argument: number, "all", or a search string
    HISTORY_ARG="${2:-15}"
    HISTORY_LIMIT="15"
    HISTORY_SEARCH=""
    if [ "$HISTORY_ARG" = "all" ]; then
        HISTORY_LIMIT="0"
    elif [[ "$HISTORY_ARG" =~ ^[0-9]+$ ]]; then
        HISTORY_LIMIT="$HISTORY_ARG"
    else
        # Non-numeric argument — treat as a search string
        HISTORY_LIMIT="0"
        HISTORY_SEARCH="$HISTORY_ARG"
    fi

    # Read history.jsonl — each line is a prompt entry with sessionId, timestamp, display, project
    # Deduplicate by sessionId, keeping the first prompt and latest timestamp
    # Load saved session modifiers (yolo, sandbox, mudbox)
    CLAUDIUS_DIR="${CLAUDIUS_DIR:-$HOME/.claudius}"
    MODIFIERS_FILE="$CLAUDIUS_DIR/session_modifiers"

    if command -v python3 > /dev/null 2>&1; then
        python3 -c "
import json, sys, os, shutil
from datetime import datetime, timezone

# Detect terminal width for dynamic truncation
term_width = shutil.get_terminal_size( ( 120, 24 ) ).columns

history_file = sys.argv[1]
limit = int(sys.argv[2]) if len(sys.argv) > 2 else 15
modifiers_file = sys.argv[3] if len(sys.argv) > 3 else ''
search_query = sys.argv[4].lower() if len(sys.argv) > 4 and sys.argv[4] else ''

# Load session modifiers (tab-separated: session_id\tmodifiers)
# Last entry wins so updated sessions get the latest modifiers
session_modifiers = {}
if modifiers_file and os.path.isfile(modifiers_file):
    with open(modifiers_file) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            parts = line.split('\t', 1)
            sid = parts[0]
            mods = parts[1] if len(parts) > 1 else ''
            session_modifiers[sid] = mods

sessions = {}

with open(history_file) as f:
    for line in f:
        line = line.strip()
        if not line:
            continue
        try:
            entry = json.loads(line)
        except json.JSONDecodeError:
            continue

        sid = entry.get('sessionId', '')
        if not sid:
            continue

        ts = entry.get('timestamp', 0)
        prompt = entry.get('display', '').strip()
        project = entry.get('project', '')

        if sid not in sessions:
            sessions[sid] = {
                'sessionId': sid,
                'first_prompt': prompt,
                'latest_ts': ts,
                'project': project,
            }
        else:
            # Update latest timestamp, keep the first non-empty prompt
            if ts > sessions[sid]['latest_ts']:
                sessions[sid]['latest_ts'] = ts
            if not sessions[sid]['first_prompt'] and prompt:
                sessions[sid]['first_prompt'] = prompt

if not sessions:
    print('No sessions found.', file=sys.stderr)
    sys.exit(0)

# Sort by latest timestamp, most recent first
sorted_sessions = sorted(sessions.values(), key=lambda s: s['latest_ts'], reverse=True)

# Filter by search query — search first prompt and full transcript text
if search_query:
    claude_dir = os.path.expanduser('~/.claude')

    def session_matches(s):
        # Quick match on first prompt
        if search_query in s['first_prompt'].lower():
            return True
        # Deep search through the full session transcript
        project = s.get('project', '')
        if not project:
            return False
        encoded_project = project.replace('/', '-')
        sid = s['sessionId']
        transcript = os.path.join(claude_dir, 'projects', encoded_project, f'{sid}.jsonl')
        if not os.path.isfile(transcript):
            return False
        try:
            with open(transcript) as tf:
                for tl in tf:
                    tl = tl.strip()
                    if not tl:
                        continue
                    # Fast pre-check on raw line before parsing JSON
                    if search_query not in tl.lower():
                        continue
                    try:
                        rec = json.loads(tl)
                    except json.JSONDecodeError:
                        continue
                    msg = rec.get('message', {})
                    content = msg.get('content', '')
                    if isinstance(content, str) and search_query in content.lower():
                        return True
                    elif isinstance(content, list):
                        for block in content:
                            if isinstance(block, dict):
                                text = block.get('text', '')
                                if text and search_query in text.lower():
                                    return True
        except (IOError, OSError):
            pass
        return False

    sorted_sessions = [s for s in sorted_sessions if session_matches(s)]
    if not sorted_sessions:
        print(f'No sessions matching \"{sys.argv[4]}\" found.', file=sys.stderr)
        sys.exit(0)

# Apply limit (0 means no limit)
if limit > 0:
    sorted_sessions = sorted_sessions[:limit]

# Build all resume commands first to find the longest one
resume_cmds = []
for entry in sorted_sessions:
    sid = entry['sessionId']
    mods = session_modifiers.get(sid, '')
    mod_prefix = f' {mods}' if mods else ''
    resume_cmds.append(f'claudius{mod_prefix} resume {sid}')

# Pad all resume commands to the same width
max_cmd_len = max(len(cmd) for cmd in resume_cmds) if resume_cmds else 0

for entry, resume_cmd in zip(sorted_sessions, resume_cmds):
    ts = entry['latest_ts']

    # Convert epoch ms to HH:MM DD-MM-YYYY
    try:
        dt = datetime.fromtimestamp(ts / 1000, tz=timezone.utc).astimezone()
        ts_str = dt.strftime('%H:%M %d-%m-%Y')
    except (ValueError, OSError):
        ts_str = '??:?? ??-??-????'

    # Pad the resume command so all rows align
    padded_cmd = resume_cmd.ljust(max_cmd_len)

    summary = entry['first_prompt'].replace('\n', ' ').strip()

    # Truncate prompt to fill the remaining terminal width
    prefix = f'{ts_str} | {padded_cmd} | '
    max_summary = term_width - len(prefix)
    if max_summary > 3 and len(summary) > max_summary:
        summary = summary[:max_summary - 3] + '...'

    print(f'{prefix}{summary}')
" "$HISTORY_FILE" "$HISTORY_LIMIT" "$MODIFIERS_FILE" "$HISTORY_SEARCH"
    else
        echo "Error: python3 is required for the history command" >&2
        exit 1
    fi

    exit 0

fi

# ---- parse chainable subcommands ----
# Commands like yolo, sandbox, mudbox, continue, and resume can be
# combined in any order: claudius yolo mudbox, claudius sandbox continue, etc.
YOLO=false
SANDBOX=false
MUDBOX=false
CONTINUE=false
RESUME=false
RESUME_NAME=""

while [ $# -gt 0 ]; do
    case "$1" in
        yolo)      YOLO=true; shift ;;
        sandbox)   SANDBOX=true; shift ;;
        mudbox)    MUDBOX=true; shift ;;
        continue)  CONTINUE=true; shift ;;
        resume)
            RESUME=true; shift
            # Next non-flag, non-subcommand argument is the session name
            if [ $# -gt 0 ] && [[ "${1:-}" != -* ]]; then
                case "$1" in
                    yolo|sandbox|mudbox|continue|resume) ;;
                    *) RESUME_NAME="$1"; shift ;;
                esac
            fi
            ;;
        *)  break ;;
    esac
done

# ---- check for updates (non-blocking, 5s timeout) ----
check_for_update() {
    local remote_version
    remote_version=$(curl -fsSL --max-time 5 \
        "$REPO_URL" 2>/dev/null \
        | grep -m1 '^CLAUDIUS_VERSION=' | cut -d'"' -f2)

    if [ -n "$remote_version" ] && [ "$remote_version" != "$CLAUDIUS_VERSION" ]; then
        echo "claudius $CLAUDIUS_VERSION → $remote_version available. Run: claudius update" >&2
    fi
}
check_for_update &

# ---- resolve authentication ----
# Priority: env var > host Claude CLI credentials file > token file > API key
#
# When we can get the full credentials JSON (with refresh token), we mount
# it into the container as .credentials.json. This lets Claude Code handle
# its own token refresh — no more expired tokens in long sessions.
OAUTH_TOKEN="${CLAUDE_CODE_OAUTH_TOKEN:-}"
CREDS_TMPFILE=""

# When no explicit token, try to mount the host's full credentials
if [ -z "$OAUTH_TOKEN" ]; then

    CREDS_JSON=""

    # On macOS, extract credentials from the Keychain
    if command -v security > /dev/null 2>&1; then
        CREDS_JSON=$(security find-generic-password -s "Claude Code-credentials" -w 2>/dev/null || true)
    fi

    # On Linux, read the credentials file
    if [ -z "$CREDS_JSON" ] && [ -f "$HOME/.claude/.credentials.json" ]; then
        CREDS_JSON=$(cat "$HOME/.claude/.credentials.json")
    fi

    # Write full credentials to a temp file for mounting into the container.
    # This gives Claude Code the refresh token so it can renew access tokens
    # on its own — no host-side refresh needed.
    if [ -n "$CREDS_JSON" ]; then
        CREDS_TMPFILE=$(mktemp)
        printf '%s' "$CREDS_JSON" > "$CREDS_TMPFILE"
        chmod 600 "$CREDS_TMPFILE"
    fi

fi

# Fall back to the claudius setup token file (static token, no refresh)
if [ -z "$CREDS_TMPFILE" ] && [ -z "$OAUTH_TOKEN" ] && [ -f "$TOKEN_FILE" ]; then
    OAUTH_TOKEN=$(sed 's/\x1b\[[0-9;]*[A-Za-z]//g' "$TOKEN_FILE" | grep -o 'sk-ant-[A-Za-z0-9_-]*' | head -n 1)
fi

# Bail if we have no authentication at all
if [ -z "$CREDS_TMPFILE" ] && [ -z "$OAUTH_TOKEN" ] && [ -z "${ANTHROPIC_API_KEY:-}" ]; then
    echo "No authentication found." >&2
    echo "" >&2
    echo "Run:  claudius setup" >&2
    echo "  or: export ANTHROPIC_API_KEY=sk-..." >&2
    exit 1
fi

# ---- safety check: warn if mounting $HOME or / as workspace ----
if [ "$SANDBOX" = false ]; then
    RESOLVED_PWD="$(pwd -P)"
    RESOLVED_HOME="$(cd "$HOME" && pwd -P)"

    if [ "$RESOLVED_PWD" = "/" ] || [ "$RESOLVED_PWD" = "$RESOLVED_HOME" ]; then
        if [ "$RESOLVED_PWD" = "/" ]; then
            warn_dir="the root directory (/)"
        else
            warn_dir="your home directory ($HOME)"
        fi
        printf 'Warning: about to mount %s as the container workspace.\n' "$warn_dir" >&2
        printf 'Are you sure? [y/N] ' >&2
        read -r confirm
        case "$confirm" in
            [yY]) ;;
            *)
                echo "Aborted." >&2
                exit 1
                ;;
        esac
    fi
fi

# ---- build docker run flags ----
docker_flags=( --rm )

# Interactive/TTY detection
if [ -t 0 ]; then
    docker_flags+=( -it )
fi

# Mount project directory as the workspace
# Mudbox: read-only mount — Sandbox: no mount — Normal: read-write mount
if [ "$MUDBOX" = true ]; then
    docker_flags+=( -v "$(pwd):/workspace:ro" )
elif [ "$SANDBOX" = false ]; then
    docker_flags+=( -v "$(pwd):/workspace" )
fi

# Mount host config so Claude skips onboarding and reads user settings
# Always create a writable copy so Claude can persist workspace trust and session state
CLAUDE_JSON_TMPFILE=$(mktemp)
if [ -f "$HOME/.claude.json" ]; then
    cp "$HOME/.claude.json" "$CLAUDE_JSON_TMPFILE"
else
    echo '{}' > "$CLAUDE_JSON_TMPFILE"
fi
chmod 600 "$CLAUDE_JSON_TMPFILE"

# Pre-seed workspace trust for /workspace to skip the trust dialog
if command -v python3 > /dev/null 2>&1; then
    python3 -c "
import json, sys
with open(sys.argv[1], 'r') as f:
    data = json.load(f)
project = data.setdefault('projects', {}).setdefault('/workspace', {'allowedTools': []})
project['hasTrustDialogAccepted'] = True
with open(sys.argv[1], 'w') as f:
    json.dump(data, f)
" "$CLAUDE_JSON_TMPFILE" 2>/dev/null || true
elif command -v jq > /dev/null 2>&1; then
    jq '.projects //= {} | .projects["/workspace"] //= {"allowedTools": []} | .projects["/workspace"].hasTrustDialogAccepted = true' \
        "$CLAUDE_JSON_TMPFILE" > "$CLAUDE_JSON_TMPFILE.tmp" \
        && mv "$CLAUDE_JSON_TMPFILE.tmp" "$CLAUDE_JSON_TMPFILE" 2>/dev/null || true
fi

docker_flags+=( -v "$CLAUDE_JSON_TMPFILE:/home/node/.claude.json" )
# In yolo mode, create a writable copy of settings.json with the bypass
# confirmation pre-accepted so Claude Code skips the "Bypass Permissions" dialog
SETTINGS_TMPFILE=""
if [ "$YOLO" = true ]; then
    SETTINGS_TMPFILE=$(mktemp)
    if [ -f "$HOME/.claude/settings.json" ]; then
        cp "$HOME/.claude/settings.json" "$SETTINGS_TMPFILE"
    else
        echo '{}' > "$SETTINGS_TMPFILE"
    fi
    chmod 600 "$SETTINGS_TMPFILE"

    if command -v python3 > /dev/null 2>&1; then
        python3 -c "
import json, sys
with open(sys.argv[1], 'r') as f:
    data = json.load(f)
data['skipDangerousModePermissionPrompt'] = True
with open(sys.argv[1], 'w') as f:
    json.dump(data, f)
" "$SETTINGS_TMPFILE" 2>/dev/null || true
    fi

    docker_flags+=( -v "$SETTINGS_TMPFILE:/home/node/.claude/settings.json" )
fi

for config_file in settings.json settings.local.json CLAUDE.md; do
    # Skip settings.json when we already mounted the yolo-patched copy
    if [ "$config_file" = "settings.json" ] && [ -n "$SETTINGS_TMPFILE" ]; then
        continue
    fi
    if [ -f "$HOME/.claude/$config_file" ]; then
        docker_flags+=( -v "$HOME/.claude/$config_file:/home/node/.claude/$config_file:ro" )
    fi
done

# Mount skills directory if it exists
if [ -d "$HOME/.claude/skills" ]; then
    docker_flags+=( -v "$HOME/.claude/skills:/home/node/.claude/skills:ro" )
fi

# Persistent named volumes for MCP server package caches
# These survive --rm so MCP servers don't re-download every run
docker_flags+=( -v "claudius-npm-cache:/home/node/.npm" )
docker_flags+=( -v "claudius-npm-global:/home/node/.npm-global" )
docker_flags+=( -v "claudius-uv-cache:/home/node/.cache" )

# Share Claude session state with host so --continue and --resume find
# sessions created on the host or in previous container runs
HOST_CLAUDE_DIR="$HOME/.claude"
mkdir -p "$HOST_CLAUDE_DIR/projects" "$HOST_CLAUDE_DIR/plans" "$HOST_CLAUDE_DIR/todos"
if [ "$SANDBOX" = true ]; then
    docker_flags+=( -v "$HOST_CLAUDE_DIR/projects:/home/node/.claude/projects:ro" )
    docker_flags+=( -v "$HOST_CLAUDE_DIR/plans:/home/node/.claude/plans:ro" )
    docker_flags+=( -v "$HOST_CLAUDE_DIR/todos:/home/node/.claude/todos:ro" )
else
    docker_flags+=( -v "$HOST_CLAUDE_DIR/projects:/home/node/.claude/projects" )
    docker_flags+=( -v "$HOST_CLAUDE_DIR/plans:/home/node/.claude/plans" )
    docker_flags+=( -v "$HOST_CLAUDE_DIR/todos:/home/node/.claude/todos" )
fi

# Persist session history so the interactive picker shows previous sessions
# touch is safe on existing files (preserves content) and bootstraps the file for new users
touch "$HOST_CLAUDE_DIR/history.jsonl"
if [ "$SANDBOX" = true ]; then
    docker_flags+=( -v "$HOST_CLAUDE_DIR/history.jsonl:/home/node/.claude/history.jsonl:ro" )
else
    docker_flags+=( -v "$HOST_CLAUDE_DIR/history.jsonl:/home/node/.claude/history.jsonl" )
fi

# Loosen seccomp so MCP servers that spawn child processes (browsers,
# language runtimes, etc.) work without hitting blocked-syscall errors.
# The container itself is the security boundary.
docker_flags+=( --security-opt "seccomp=unconfined" )

# Pass authentication — prefer mounting credentials file (supports refresh)
# over a static token env var (expires and can't be renewed)
if [ -n "$CREDS_TMPFILE" ]; then
    docker_flags+=( -v "$CREDS_TMPFILE:/home/node/.claude/.credentials.json" )
elif [ -n "$OAUTH_TOKEN" ]; then
    docker_flags+=( -e "CLAUDE_CODE_OAUTH_TOKEN=$OAUTH_TOKEN" )
fi

if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
    docker_flags+=( -e "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY" )
fi

# Set the model
docker_flags+=( -e "CLAUDE_MODEL=$MODEL" )

# Expose the run mode inside the container for scripts and agents to check
# Priority: yolo > mudbox > sandbox > regular
if [ "$YOLO" = true ]; then
    docker_flags+=( -e "CLAUDIUS_MODE=yolo" )
elif [ "$MUDBOX" = true ]; then
    docker_flags+=( -e "CLAUDIUS_MODE=mudbox" )
elif [ "$SANDBOX" = true ]; then
    docker_flags+=( -e "CLAUDIUS_MODE=sandbox" )
else
    docker_flags+=( -e "CLAUDIUS_MODE=regular" )
fi

# Build Claude CLI flags
claude_flags=( --model "$MODEL" )

# Base system prompt: orient Claude to the container environment
SYSTEM_PROMPT="You are running inside a Claudius Docker container — an isolated sandbox built for coding agents. You have passwordless sudo for any operation that needs root. Your workspace is /workspace (bind-mounted from the host). For a full reference of installed CLI tools and capabilities, read /home/node/AGENTS.md.

Do NOT add Co-Authored-By lines to git commit messages. The git author identity is already configured via environment variables."

# In sandbox mode, tell Claude there is no workspace
if [ "$SANDBOX" = true ]; then
    SYSTEM_PROMPT="$SYSTEM_PROMPT

You are running in SANDBOX mode (CLAUDIUS_MODE=sandbox). There is no workspace mounted — the /workspace directory is empty and container-local. All host files are mounted read-only. You cannot modify anything on the host. Use this session for general questions, research, brainstorming, or tasks that don't need access to a project."
fi

# In mudbox mode, tell Claude the workspace is read-only
if [ "$MUDBOX" = true ]; then
    SYSTEM_PROMPT="$SYSTEM_PROMPT

You are running in MUDBOX mode (CLAUDIUS_MODE=mudbox). The workspace at /workspace is mounted READ-ONLY from the host. You can read and explore all project files but cannot modify them. Use this mode for code review, analysis, exploration, or generating patches. Any files you need to create must go in a container-local directory outside /workspace."
fi

# In yolo mode, extend the prompt with autonomy instructions
if [ "$YOLO" = true ]; then
    claude_flags+=( --dangerously-skip-permissions )
    SYSTEM_PROMPT="$SYSTEM_PROMPT

You are running in YOLO mode (CLAUDIUS_MODE=yolo). The environment variable \$CLAUDIUS_MODE is set to 'yolo'. In this mode you are expected to act with maximum autonomy — fulfill the user's intent with as little interaction as possible. Do not ask for confirmation before taking actions. Prefer doing over asking. If a task is ambiguous, make a reasonable choice and proceed."
fi

claude_flags+=( --append-system-prompt "$SYSTEM_PROMPT" )

# Resume most recent session
if [ "$CONTINUE" = true ]; then
    claude_flags+=( --continue )
fi

# Resume a specific or picked session
if [ "$RESUME" = true ]; then
    if [ -n "$RESUME_NAME" ]; then
        claude_flags+=( --resume "$RESUME_NAME" )
    else
        claude_flags+=( --resume )
    fi
fi

# ---- ensure the image is available ----
if ! docker image inspect "$IMAGE" > /dev/null 2>&1; then

    echo "Image $IMAGE not found locally, pulling..." >&2
    if ! docker pull "$IMAGE"; then

        echo "Pull failed, building image locally..." >&2
        # When invoked via PATH, $0 has no directory component — resolve with command -v
    case "$0" in
        */*) SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)" ;;
        *)   SCRIPT_DIR="$(dirname "$(command -v "$0")")" ;;
    esac

        if [ ! -f "$SCRIPT_DIR/Dockerfile" ]; then
            echo "Error: Dockerfile not found at $SCRIPT_DIR/Dockerfile" >&2
            exit 1
        fi

        docker build -t "$IMAGE" "$SCRIPT_DIR"

    fi

    echo "Image $IMAGE is ready." >&2

fi

# ---- clean up temporary files on exit ----
cleanup() {
    [ -n "$CLAUDE_JSON_TMPFILE" ] && rm -f "$CLAUDE_JSON_TMPFILE"
    [ -n "$SETTINGS_TMPFILE" ] && rm -f "$SETTINGS_TMPFILE"
    [ -n "$CREDS_TMPFILE" ] && rm -f "$CREDS_TMPFILE"
}
trap cleanup EXIT

# ---- run claude in the container ----

# Record history state so we can detect new sessions
HISTORY_FILE="$HOST_CLAUDE_DIR/history.jsonl"
history_lines_before=0
if [ -f "$HISTORY_FILE" ]; then
    history_lines_before=$(wc -l < "$HISTORY_FILE")
fi

docker run "${docker_flags[@]}" "$IMAGE" claude "${claude_flags[@]}" "$@"
exit_code=$?

# Show claudius resume hint if a session was active
if [ -f "$HISTORY_FILE" ]; then
    history_lines_after=$(wc -l < "$HISTORY_FILE")
    if [ "$history_lines_after" -gt "$history_lines_before" ]; then
        session_id=$(tail -1 "$HISTORY_FILE" | grep -o '"sessionId":"[^"]*"' | head -1 | cut -d'"' -f4)
        if [ -n "$session_id" ]; then
            # Reconstruct the modifier flags used in this session
            modifiers=""
            [ "$YOLO" = true ] && modifiers="$modifiers yolo"
            [ "$SANDBOX" = true ] && modifiers="$modifiers sandbox"
            [ "$MUDBOX" = true ] && modifiers="$modifiers mudbox"

            # Persist modifiers so `claudius history` can show them
            CLAUDIUS_DIR="${CLAUDIUS_DIR:-$HOME/.claudius}"
            mkdir -p "$CLAUDIUS_DIR"
            printf '%s\t%s\n' "$session_id" "${modifiers# }" >> "$CLAUDIUS_DIR/session_modifiers"

            printf '\n  Resume this session with:\n  claudius%s resume %s\n\n' "$modifiers" "$session_id"
        fi
    fi
fi

exit $exit_code
